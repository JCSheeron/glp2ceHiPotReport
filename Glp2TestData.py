#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Glp2TestData.py
#
# This object holds test data that originates from a csv file generated by
# a Schleich tester. The csv file is actually uses a ";" as a seperator character,
# and presumably is opened, imported, and then passed to this object as a list.
# This list is actually a list of lists: It is a list of rows, and each row
# is a list of values.
#
# The data normally has the format:
# [ [row0col0val, row0col1val, row0col2val, row0cal3val ...],
#   [row1col0val, row1col1val, row1col2val, row1cal3val ...],
#   [row2col0val, row2col1val, row2col2val, row1cal3val ...],
#   ... ]
# NOTE: The data file contains the header info in the first row.  This object
# assumes the data passed to the constructor does not have header info, and the
# header info is instead passed as the data paramater.
#
# This object uses a tuple to store the header, and tuple to store the test data.
#
# The index passed to the constructor are defaulted to the correct zero based column
# numbers. Paramters are used so the values can be changed if needed.
#
# Since many of the values in the data are systemic, they are repeated for all the
# rows. For example, if a particular test is run on a particular machine, and the
# test had 5 steps, each step will have the same value for device number, program
# name, program guid, and the test guid.  For this reason, the properties that
# retreive values based on column use a step parameter that is defaulted to 1 to
# get the value from the first row. Note that steps are 1 based, and rows/list
# elements are 0 based.

# imports
from Glp2TestDataStep import Glp2TestDataStep

class Glp2TestData(object):
    def __init__(self, data=None, header=None, testGuidIdx=0, testProgramNameIdx=25,
                 testProgramGuidIdx=49, deviceNumberIdx=31, testStepGuidIdx=1,
                 stepNumberIdx=2, timestampIdx=30, graphDataIdx=76):
        # The data expected is a tuple, list, or something convertable to a
        # tuple that has an entire row of data from a test data file.  The
        # indexes are the normal column counts, starting at zero.
        #
        # These parameters are just passed through to the Glp2TestDataStep ctor:
        #   testStepGuidIdx
        #   stepNumberIdx
        #   timestampIdx
        #   deviceNumberIdx (used by both Glp2TestData and Glp2TestDataStep)
        #   graphDataIdx
        #
        # Set the header. Do this first so it is available to make
        # steps later.
        if header is None: # no header specified
            self._dataHeader = None
        else: # header specified
            try:
                # header is specified, but it must be convertable to a tuple.
                self._dataHeader = tuple(header)
            except ValueError as ve:
                print('Value Error: The header parameter must be a tuple, \
or something convertable to a tuple. This generally means it must be something \
iteratable. Setting the header to None.')
                print(ve)
                self._dataHeader = None
        # set up the data
        if data is not None: # data provided
            # make sure the data is convertable to a tuple. If not, report an
            # error -- a tuple is immutable, so an empty one isn't very useful.
            try:
                self._rawData=tuple(data)
                # if we get here, we should have a tuple with something in it
                # Assume it is a multi element tuple, with each element containing
                # details of a test step.

            except ValueError as ve:
                print('Value Error: data parameter must be a tuple or something \
convertalbe to a tuple. This generally means it must be something iteratable. \
No Data Captured.')
                print(ve)
                self._rawData = None
                self._steps = None
                quit()

            # Set up test step objects to contain the step details.
            if len(self._rawData) > 0:
                # If there is someting in the data (at least 1 step)...
                # Assume it is an list of step details (list of lists)
                steps=[]
                for idx, row in enumerate(self._rawData):
                    if len(row) >= 1: # skip blank rows
                        # Add a step object to the list of step objects,
                        # passing the parameters through that the step ctor needs.
                        steps.append(Glp2TestDataStep(row, self._dataHeader,
                                     testStepGuidIdx=testStepGuidIdx,
                                     stepNumberIdx=stepNumberIdx,
                                     timestampIdx=timestampIdx,
                                     deviceNumberIdx=deviceNumberIdx,
                                     graphDataIdx=graphDataIdx))
                # All the steps have been retreived.
                # Put them into a memeber tuple
                self._steps = tuple(steps)
        else: # data not provided
            self._steps = None

        self._testGuidIdx = testGuidIdx
        self._testProgramNameIdx = testProgramNameIdx
        self._testProgramGuidIdx = testProgramGuidIdx
        self._deviceNumberIdx = deviceNumberIdx

    def __repr__(self):
        outputMsg=  '{:16} {}\n'.format('Test Id: ', self.testGuid)
        outputMsg=  '{:16} {}\n'.format('Test Dfn (Program) Name: ', self.testProgramName)
        outputMsg+= '{:16} {}\n'.format('Test Dfn (Program) Id: ', self.testProgramGuid)
        outputMsg+= '{:16} {}\n'.format('Device Number: ', self.deviceNumber)
#        # header
#        outputMsg+= '\n{:16} \n'.format('Data Header: ')
#        if self._dataHeader is not None:
#            for idx, heading in enumerate(self._dataHeader):
#                outputMsg+= '  {:2}: {}\n'.format(idx, heading)
#        else:
#            outputMsg+= '  No Header\n'
#
        if self._steps is not None:
            outputMsg+= '\n{:16}\n'.format('Steps: ')
            for step in self._steps:
                outputMsg+= str(step)
#
#        # data - may include header info also
#        if self._dataHeader is not None and self._rawData is not None:
#            # data and header info avail -- include header info
#            outputMsg+= '{:16} \n'.format('Test Data: ')
#            for idx, heading in enumerate(self._dataHeader):
#                for value in self._rawData:
#                    outputMsg+= '  {:4}-{:4<}: {}\n'.format(idx, heading, value)
#        elif self._dataHeader is None and self._rawData is not None:
#            # data but no header info
#            for idx, value in enumerate(self._rawData):
#                outputMsg+= '  {:4}: {}\n'.format(idx, value)
#        else:
#            # no data stored!!
#            outputMsg+= '  No Data\n'
        return(outputMsg)

    # properties

    @property
    def testGuid(self, step=1):
        # steps start at 1
        if self._rawData is not None and step >= 1 and step <= len(self._rawData):
            # there is raw data and the step is within range (within the width of a row)
            if self._testGuidIdx + 1 <= len(self._rawData[step - 1]):
                # the index is within range
                return self._rawData[step - 1][self._testGuidIdx]
            else: # index out of range
                return None
        else: # no data or step out of range
            return None

    @property
    def testProgramName(self, step=1):
        # steps start at 1
        if self._rawData is not None and step >= 1 and step <= len(self._rawData):
            # there is raw data and the step is within range (within the width of a row)
            if self._testProgramNameIdx + 1 <= len(self._rawData[step - 1]):
                # the index is within range
                return self._rawData[step - 1][self._testProgramNameIdx]
            else: # index out of range
                return None
        else: # no data or step out of range
            return None

    @property
    def testProgramGuid(self, step=1):
        # steps start at 1
        if self._rawData is not None and step >= 1 and step <= len(self._rawData):
            # there is raw data and the step is within range (within the width of a row)
            if self._testProgramGuidIdx + 1 <= len(self._rawData[step - 1]):
                # the index is within range
                return self._rawData[step - 1][self._testProgramGuidIdx]
            else: # index out of range
                return None
        else: # no data or step out of range
            return None

    @property
    def deviceNumber(self, step=1):
        # steps start at 1
        if self._rawData is not None and step >= 1 and step <= len(self._rawData):
            # there is raw data and the step is within range (within the width of a row)
            if self._deviceNumberIdx + 1 <= len(self._rawData[step - 1]):
                # the index is within range
                return self._rawData[step - 1][self._deviceNumberIdx]
            else: # index out of range
                return None
        else: # no data or step out of range
            return None

    @property
    def steps(self):
        return len(self._rawData)

    @property
    def header(self):
        return (self._dataHeader)

    @header.setter
    def header(self, headerData):
        if headerData is not None:
            try:
                # header is specified, but it must be convertable to a tuple.
                self._dataHeader = tuple(headerData)
            except ValueError as ve:
                print('Value Error: The header parameter must be a tuple, or something \
convertable to a tuple. This generally means it must be something iteratable. \
Header not changed.')
                print(ve)
        else: # nothing specified for header
            self._dataHeader = None



    @property
    def data(self):
        return self._rawData

    @data.setter
    def data(self, data):
        if data is not None: # data provided
            # make sure the data is convertable to a tuple. If not, report an
            # error -- a tuple is immutable, so an empty one isn't very useful.
            try:
                self._rawData=tuple(data)
                # if we get here, we should have a tuple with something in it
                # Assume it is a multi element tuple, with each element containing
                # the details of a test step.
            except ValueError as ve:
                print('Value Error: The data parameter must be a tuple or something \
convertalbe to a tuple. This generally means it must be something iteratable. \
Data not changed.')
                print(ve)
        else: # no data provided
            self._rawData = None




