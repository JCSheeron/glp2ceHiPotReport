#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Glp2TestDataStep.py
#
# This object holds test step data that originates from a csv file generated by
# a Schleich tester. The csv file is actually uses a ";" as a seperator character,
# and presumably is opened, imported, and then passed to a GlpTestData object.  The
# GlpTestData object breaks the test data into steps, presumably using this object
# to store the steps.
#
# Stored in this object is a header row, and the test step details for a single
# step.  These are both lists, with the index of the header list "lining up" with
# the index of the test step details
#
# The data normally has the format:
# header:   [headercol0, headercol1, headercol2, ...]
# data:     [col0val, col1val, col2val, ...]
# Included in the data is the graph data, which itself is a (non-python) list of
# data, delimited by the "|" character.
#
# NOTE: The data file contains the header info in the first row.  This object
# assumes the data passed to the constructor does not have header info, and the
# header info is instead passed as the data paramater. When a batch of steps are
# associated with a test and stored, the heaer info is repeated in each one.  This
# is a bit redundant and wasteful, but I chose this so an individual step can
# stand alone and contain enough information so that the step details can be
# interpreted.
#
# Tuples are used to store the header and step details, since tuples are
# immutable.
#
# The index passed to the constructor are defaulted to the correct zero based column
# numbers. Paramters are used so the values can be changed if needed.
#
# imports
#
# TODO: Add operator field
#
class Glp2TestDataStep(object):
    def __init__(self, data=None, header=None, decimalSeparator = ',',
                 testStepGuidIdx=1, stepNumberIdx=2, deviceNumberIdx=31,
                 nomVoltIdx=6, nomVoltUnitIdx=7, actVoltIdx=8,
                 actVoltUnitIdx=9, currentLimIdx=10, currentLimUnitIdx=11,
                 actCurrIdx=12, actCurrUnitIdx=13, timestampIdx=30, graphDataIdx=76):
        # The data expected is a tuple, list, or something convertable to a
        # tuple shat has an entire row of data from a test data file.  The
        # indexes are the normal column counts, starting at zero.
        #
        # Set the header. Do this first so it is available later if needed.
        if header is not None: # header specified
            try:
                # header is specified, but it must be convertable to a tuple.
                self._dataHeader = tuple(header)
            except ValueError as ve:
                print('Value Error: The header parameter must be a tuple, or something \
convertable to a tuple. This generally means it must be something iteratable. \
Header not changed.')
                print(ve)
                self._dataHeader = None
        else: # no header specified
            self._dataHeader = None
        # set up the data
        if data is not None: # data provided
            # make sure the data is convertable to a tuple. If not, report an
            # error -- a tuple is immutable, so an empty one isn't very useful.
            try:
                self._rawData=tuple(data)
                # if we get here, we should have a tuple with something in it
                # Assume it is a multi element tuple, with each element containing
                # the details of a test step.
            except ValueError as ve:
                print('Value Error: The data parameter must be a tuple or something \
convertalbe to a tuple. This generally means it must be something iteratable. \
No step information captured.')
                print(ve)
                self._rawData = None
        else: # no data provided
            self._rawData = None

        self._decimalSeparator = decimalSeparator
        self._testStepGuidIdx = testStepGuidIdx
        self._stepNumberIdx = stepNumberIdx
        self._deviceNumberIdx = deviceNumberIdx
        self._nomVoltIdx = nomVoltIdx
        self._nomVoltUnitIdx = nomVoltUnitIdx
        self._actVoltIdx = actVoltIdx
        self._actVoltUnitIdx = actVoltUnitIdx
        self._currentLimIdx = currentLimIdx
        self._currentLimUnitIdx = currentLimUnitIdx
        self._actCurrIdx = actCurrIdx
        self._actCurrUnitIdx = actCurrUnitIdx
        self._timestampIdx = timestampIdx
        self._graphDataIdx = graphDataIdx

    def __repr__(self):
        outputMsg=  '{:21}{:<23}{:18}{}\n'.format('Test Step Number: ',
                                                    self.stepNumber,
                                                    'Test Step GUID: ',
                                                    self.testStepGuid)
        outputMsg+= '{:21}{}\n'.format('Device Number: ',
                                          self.deviceNumber)
        outputMsg+= '{:21}{:23}{:18}{}\n'.format('Nominal Voltage: ',
                                                    str(self.nominalVoltage) + ' ' +
                                                    str(self.nominalVoltageUnit),
                                                    'Measured Voltage: ',
                                                    str(self.measuredVoltage) + ' ' +
                                                    str(self.measuredVoltageUnit))
        outputMsg+= '{:21}{:23}{:18}{}\n'.format('Current Limit: ',
                                                    str(self.currentLimit) + ' ' +
                                                    str(self.currentLimitUnit),
                                                    'Measured Current: ',
                                                    str(self.measuredCurrent) + ' ' +
                                                    str(self.measuredCurrentUnit))
        outputMsg+= '{:21}{}\n\n'.format('Test Step Timestamp: ', self.testTimestamp)
        # print out all the test data. Use the header if it is available
        if self.header is not None and self.data is not None:
            # both header and data available
            outputMsg += '{}'.format('Header and data available.\n')
            outputMsg += '{}'.format('(Col) Heading: Value\n')
            for col, colHeading in enumerate(self.header):
                outputMsg += '({:3d}) {:27}: {}\n'.format(col, colHeading, self.data[col])
        elif self.header is not None and self.data is None:
            # header but no data available
            outputMsg += '{}'.format('Header available, but no data available.\n')
            outputMsg += '{}'.format('(Col) Heading\n')
            for col, colHeading in enumerate(self.header):
                outputMsg += '({:3d}) {}\n'.format(col, colHeading)
        elif self.header is None and self.data is not None:
            # no header but data is avilable
            outputMsg += '{}'.format('No header available, but data available.\n')
            outputMsg += '{}'.format('(Col) Value\n')
            for col, value in enumerate(self.data):
                outputMsg += '({}) {}\n'.format(str(col), value )
        else:
            # no data and no header
            pass # nothing to do
        return(outputMsg)

    # properties
    @property
    def testStepGuid(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._testStepGuidIdx + 1 <= len(self._rawData):
            return self._rawData[self._testStepGuidIdx]
        else:
            return None

    @property
    def stepNumber(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._stepNumberIdx + 1 <= len(self._rawData):
            return int(self._rawData[self._stepNumberIdx])
        else:
            return None

    @property
    def deviceNumber(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._deviceNumberIdx + 1 <= len(self._rawData):
            return self._rawData[self._deviceNumberIdx]
        else:
            return None

    @property
    def nominalVoltage(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._nomVoltIdx + 1 <= len(self._rawData):
            if self._decimalSeparator == ',':
                # if using a comma as a decimal separator, also assume a period
                # may be used as a thousands separator.  First replace all periods
                # with an empty string (get rid of them), and then replace all commas
                # with periods.
                return float(self._rawData[self._nomVoltIdx].replace('.','').replace(',', '.'))
            else: # assume decimal separator is a period
                return float(self._rawData[self._nomVoltIdx])
        else:
            return None

    @property
    def nominalVoltageUnit(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._nomVoltUnitIdx + 1 <= len(self._rawData):
            return self._rawData[self._nomVoltUnitIdx]
        else:
            return None

    @property
    def measuredVoltage(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._actVoltIdx + 1 <= len(self._rawData):
            if self._decimalSeparator == ',':
                # if using a comma as a decimal separator, also assume a period
                # may be used as a thousands separator.  First replace all periods
                # with an empty string (get rid of them), and then replace all commas
                # with periods.
                return float(self._rawData[self._actVoltIdx].replace('.','').replace(',', '.'))
            else: # assume decimal separator is a period
                return float(self._rawData[self._actVoltIdx])
        else:
            return None

    @property
    def measuredVoltageUnit(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._actVoltUnitIdx + 1 <= len(self._rawData):
            return self._rawData[self._actVoltUnitIdx]
        else:
            return None

    @property
    def currentLimit(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._currentLimIdx + 1 <= len(self._rawData):
            if self._decimalSeparator == ',':
                # if using a comma as a decimal separator, also assume a period
                # may be used as a thousands separator.  First replace all periods
                # with an empty string (get rid of them), and then replace all commas
                # with periods.
                return float(self._rawData[self._currentLimIdx].replace('.','').replace(',', '.'))
            else: # assume decimal separator is a period
                return float(self._rawData[self._currentLimIdx])
        else:
            return None

    @property
    def currentLimitUnit(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._currentLimUnitIdx + 1 <= len(self._rawData):
            return self._rawData[self._currentLimUnitIdx]
        else:
            return None

    @property
    def measuredCurrent(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._actCurrIdx + 1 <= len(self._rawData):
            if self._decimalSeparator == ',':
                # if using a comma as a decimal separator, also assume a period
                # may be used as a thousands separator.  First replace all periods
                # with an empty string (get rid of them), and then replace all commas
                # with periods.
                return float(self._rawData[self._actCurrIdx].replace('.','').replace(',', '.'))
            else: # assume decimal separator is a period
                return float(self._rawData[self._actCurrIdx])
        else:
            return None

    @property
    def measuredCurrentUnit(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._actCurrUnitIdx + 1 <= len(self._rawData):
            return self._rawData[self._actCurrUnitIdx]
        else:
            return None

    @property
    def testTimestamp(self):
        # get the value from the raw data if the data is present
        if self._rawData is not None and self._timestampIdx + 1 <= len(self._rawData):
            return self._rawData[self._timestampIdx]
        else:
            return None

    @property
    def graphData(self):
        # get the graph data from the raw data if it is present
        if self._rawData is not None and self._graphDataIdx + 1 <= len(self._rawData):
            return self._rawData[self._graphDataIdx]
        else: # index out of range
            print('graphData index OOR')
            return None

    @property
    def len(self): # column count, 1 based
        return len(self._rawData)

    @property
    def header(self):
        return (self._dataHeader)

    @header.setter
    def header(self, headerData):
        if headerData is not None:
            try:
                # header is specified, but it must be convertable to a tuple.
                self._dataHeader = tuple(headerData)
            except ValueError as ve:
                print('Value Error: The header parameter must be a tuple, or something \
convertable to a tuple. This generally means it must be something iteratable. \
Header not changed.')
                print(ve)
        else: # nothing specified for header
            self._dataHeader = None

    @property
    def data(self):
        return self._rawData

    @data.setter
    def data(self, data):
        if data is not None: # data provided
            # make sure the data is convertable to a tuple. If not, report an
            # error -- a tuple is immutable, so an empty one isn't very useful.
            try:
                self._rawData=tuple(data)
                # if we get here, we should have a tuple with something in it
                # Assume it is a multi element tuple, with each element containing
                # the details of a test step.
            except ValueError as ve:
                print('Value Error: The data parameter must be a tuple or something \
convertalbe to a tuple. This generally means it must be something iteratable. \
Data not changed.')
                print(ve)
        else: # no data provided
            self._rawData = None

